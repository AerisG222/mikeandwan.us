@{
    Layout = "_LayoutSidebar";
    ViewBag.Title = "reference | .net guidelines | design for extensibility";
}

@section header {
    <h1>.Net Framework Design Guidelines</h1>
}

@section sidebar {
    @Html.Partial("_ReferenceSidebar", new SidebarModel() { Group = "dotnet", Item = "dotnet-guidelines-design-for-extensibility" })
}

<h2>Designing For Extensibility</h2>

<table class="table table-responsive table-striped table-hover table-sm">
  	<tbody>
	    <tr><td>Consider</td><td>Unsealed classes with no added virtual or protected members as a great way to provide inexpensive yet much appreciated extensibility to a framework.</td></tr>
	    <tr><td>Consider</td><td>Using protected members for advanced customization.</td></tr>
	    <tr><td>Do</td><td>Treat protected members on unsealed classes as public for the purpose of security, documentation, and compatibility analysis.</td></tr>
	    <tr><td>Consider</td><td>Using callbacks to allow users to provide custom code to be executed by the framework.</td></tr>
	    <tr><td>Consider</td><td>Using events to allow users to customize the behavior of a framework without the need for understanding object-oriented design.</td></tr>
	    <tr><td>Do</td><td>Prefer events over plain callbacks as they are more familiar to a broader range of developers and are integrated with Visual Studio.</td></tr>
	    <tr><td>Avoid</td><td>Using callbacks in performance-sensitive APIs.</td></tr>
	    <tr><td>Do</td><td>Understand that by calling a delegate, you are executing arbitrary code and that could have security, correctness, and compatibility repercussions.</td></tr>
	    <tr><td>Do Not</td><td>Make members virtual unless you have a good reason to do so and you are aware of all the costs related to designing, testing, and maintaining virtual members.</td></tr>
	    <tr><td>Consider</td><td>Limiting extensibility to only that absolutely necessary through the use of the Template Method Pattern.</td></tr>
	    <tr><td>Do Not</td><td>Provide abstractions unless they are tested by developing several concrete implementations and APIs consuming the abstractions.</td></tr>
	    <tr><td>Do</td><td>Choose carefully between an abstract class and an interface when designing an abstraction.</td></tr>
	    <tr><td>Consider</td><td>Providing reference tests for concrete implementations of abstractions.</td></tr>
	    <tr><td>Consider</td><td>Making base classes abstract even if they don't contain any abstract members.</td></tr>
	    <tr><td>Consider</td><td>Placing base classes in a separate namespace from the mainline scenario types.</td></tr>
	    <tr><td>Avoid</td><td>Naming base classes with a &ldquo;Base&rdquo; suffix if the class is intended for use in public APIs.</td></tr>
	    <tr><td>Do Not</td><td>Seal classes without having a good reason to do so.</td></tr>
	    <tr><td>Do Not</td><td>Declare protected or virtual members on sealed types.</td></tr>
	    <tr><td>Consider</td><td>Sealing members that you override.</td></tr>
    </tbody>
</table>
